# 3장 파드: 쿠버네티스 컨테이너 실행

## 파드 소개

* 파드가 여러 컨테이너를 가질 경우, 파드내의 모든 컨테이너는 항상 하나의 워커 노드에서 실행되며 여러 워커노드에 걸쳐 실행되지 않는다.
* 컨테이너를 직접 쓰는 대신 파드를 사용하는 이유
  * 컨테이너는 단일 프로세스를 실행하는 것을 목적으로 설계됨. 특정 컨테이너 내에서 다른 프로세스를 실행하는 것도 가능은 하지만 해당 프로세스들을 실행하고 로그를 관리하는 일련의 작업을 모두 사용자가 책임져야함 (개별 프로세스가 실패하는 경우 자동으로 재시작하는 매커니즘 등). 표준 출력으로 모든 로그가 섞이게 되면 로그를 파악하기도 어려워짐
  * 여러 프로세스를 단일 컨테이너로 묶지 않기 때문에 컨테이너들을 묶고 하나의 단위로 관리할 수 있는 상위 구조가 필요한데 이 구조가 바로 파드임.
  * 파드를 통해 밀접하게 연관된 프로세스를 함께 실행하고 단일 컨테이너안에서 함께 실행되는 것처럼 (거의) 유사한 환경을 제공하면서도 이들을 격리된 상태로 유지할 수 있음. 
* 파드의 모든 컨테이너는 동일한 네트워크 네임스페이스, UTS 네임스페이스안에서 실행되므로 모든 컨테이너는 같은 호스트 이름과 네트워크 인터페이스를 공유함
  * 파드내의 모든 컨테이너가 동일 IP와  포트 공간을 공유한다는 뜻임.
* 비슷하게 동일 IPC 네임스페이스 아래에서 실행되므로 IPC를 통해 서로 통신 가능
* (확인필요) 최신 버전은 PID 네임스페이스도 공유가능하다고 함.
* 하지만 파일시스템은 볼륨 개념(6장)을 활용한다.
* 파드는 논리적인 호스트로서 하나의 물리적 호스트나 VM과 매우 유사하게 동작한다고 볼 수 있음.
  * 동일한 파드에서 실행한 프로세스는 각 프로세스가 컨테이너 안에 캡슐화되어 있다는 점이 다름

#### 파드 간 플랫 네트워크

* 클러스터 내의 파드는 하나의 flat한 공유 네트워크 주소 공간에 상주하므로 모든 파드는 다른 파드의 IP 주소를 사용해 접근 가능함. 둘 사이에는 어떠한 NAT 도 존재하지 않음.
* 대상 파드가 다른 워커 노드에 있는지는 중요하지 않음. 실제 노드 간 네트워크 토폴로지에 관계없이 LAN 내의 컴퓨터 간 통신과 유사함.
* 이는 물리 네트워크 위에 추가적인 소프트웨어 정의 네트워크 계층을 제공하기 때문에 가능한 것.

#### 파드에서 컨테이너의 적절한 구성

* 레거시로 프론트엔드서버, 백엔드서버가 있었다면 각 역할에 따라 별도의 파드로 구분하는게 적절하다.
* 무엇보다 프론트, 백엔드는 스케일아웃 요건 자체가 다르기 때문이다. 단일 파드로 묶어버리면 스케일아웃도 파드 단위로만 가능한데 실제 환경에서는 프론트만 늘리고 싶을 수 있고 DB같은 백엔드는 거의 스케일아웃이 불가능할 수도 있다.
* 일반적으로 단일 파드에 여러 컨테이너가 들어가는 경우는 주요 프로세스와 하나 이상의 보완 프로세스로 구성하는 경우임.
  * 주 컨테이너 : 특정 디렉토리의 파일을 제공하는 웹 서버
  * 보조(사이드카) 컨테이너 : 외부 소스에서 주기적으로 콘텐츠를 받아 웹서버의 디렉토리에 저장하는 컨테이너, 로그 로테이터와 수집 컨테이너, 데이터 프로세서 컨테이너, 모니터링 에이전트 컨테이너 등
* 두 개 이상의 컨테이너를 단일 파드에 넣을지 별도 파드로 구성할지 결정하기 위한 기본질문
  1. 컨테이너를 함께 실행해야 하는가, 혹은 서로 다른 호스트에서 실행할 수 있는가?
  2. 여러 컨테이너가 모여 하나의 구성 요소를 나타내는가, 혹은 개별적인 구성 요소인가?
  3. 컨테이너가 함께, 혹은 개별적으로 스케일링되야 하는가?
* 일반적으로 특정한 이유때문에 반드시 컨테이너를 단일 파드로 구성해야 하는게 아니라면 분리된 파드에서 컨테이너를 실행하는게 좋다.

## YAML 또는 JSON 디스크립터로 파드 생성

* 파드를 포함한 쿠버네티스 리소스는 일반적으로 쿠버네티스 REST API에 JSON혹은 YAML 매니페스트를 전송해 생성한다.
  * `kubectl run` 같은 명령어 기반도 있지만 테스트 용도로나 적합한다.
  * 파일 기반으로 생성함으로써 git 등의 SCM 으로 관리하기도 용이하다.
* 풀스펙문서 https://kubernetes.io/docs/concepts/overview/kubernetes-api/
```bash
# 또는 kubectl 명령을 통해서도 각 속성에 대한 문서를 볼 수 있음
kubectl explain pods
kubectl explain pod.spec
```

---

* yaml 의 기본 구성
  * apiVersion : 이 디스크립터에서 사용한 쿠버네티스 API 버전
  * kind : 쿠버네티스 오브젝트, 리소스 유형
  * metadata : 파드 메타데이터 (이름, 네임스페이스, 레이블, 어노테이션 등)
  * spec : 파드 컨테이너, 볼륨, 기타 데이터 등 파드 자체에 대한 실제 명세
  * status : 파드 상태, 각 컨테이너 설명과 상태, 파드 내부 IP 등 현재 실행 중인 파드의 현재 정보.
    * 현재 상태를 보기 위한 읽기 전용 데이터이므로 새 파드를 만들 때 정의하는 부분은 아님.

--- 

* yaml 예제 : [kubia-manual.yaml](kubia-manual.yaml)
* yaml에 정의한 포트 정의는 단순 정보이고 실제로 다른 클라이언트에서 포트를 통해 파드에 연결할 수 있는지 여부에는 영향을 미치지 않음. 하지만 이를 통해 다른 사용자가 빠르게 파드를 사용하기 위한 포트 정보를 얻을 수 있음.

```bash
# yaml 로 리소스 생성하기
kubectl create -f kubia-manual.yaml
# 실행중인 리소스의 전체 정의를 yaml, json 로 얻기
kubectl get po kubia-manual -o yaml
kubectl get po kubia-manual -o json
```

---

*  파드의 로그 (표준출력) 얻기
*  기본 정책으로 하루 단위로 로그 파일이 10MB 크기에 도달할 때마다 순환됨. `kubectl logs` 명령은 마지막으로 순환된 로그만 보여줌.
*  현재 존재하는 파드의 로그만 얻을 수 있으며 파드가 삭제되면 로그도 삭제됨. 영구적으로 저장하려면 중앙집중식 로깅을 설정해야함 (17장)
```bash
k logs kubia-manual
# 파드내에 여러 컨테이너가 있을 경우에는 -c 옵션으로 컨테이너까지 명시할 수 있음
k logs kubia-manual -c kubia
```

---

* 파드에 요청 보내기
* 로컬 네트워크 포트를 파드의 포트로 포워딩
* 서비스같은 리소스를 사용하지 않고 디버깅이나 테스트를 목적으로 특정 파드와 통신하고 싶을 때 port-forward 명령을 사용할 수 있음
```bash
# 클라이언트 머신의 로컬 포트 8888을 클러스내의 kubia-manual 파드 8080 포트로 보내주는 프로세스를 구동 (클라이언트 머신에 구동되는 것임)
k port-forward kubia-manual 8888:8000

# shell 을 하나 더 띄워서 확인
curl localhost:8888
```

## 레이블을 이용한 파드 구성

* 레이블은 파드와 모든 다른 쿠버네티스 리소스를 조직화할 수 있는 기능
  * 예를 들어 마이크로서비스라면 각 서비스별로 그룹화할 수 있음
  * 또 같은 서비스라도 안정버전, 베타버전, 카나리 릴리스 등으로 그룹화하는 것도 가능
* 여러 개의 레이블을 가질 수 있어 다양한 그룹화가 가능

```bash
k create -f kubia-manual-with-labels.yaml
# pod의 라벨 확인
k get po --show-labels
# -L 스위치에 라벨을 지정하면 각 레이블을 자체 열에 표시할 수 있음
k get po -L creation_method,env

# 이미 존재하는 파드에 레이블 설정하기
k label po kubia-manual creation_method=manual
# 기존에 설정된 레이블을 수정하려면 --overwrite 옵션을 줘야함
k label po kubia-manual-v2 env=debug --overwrite
```

## 레이블 셀렉터를 이용한 파드 부분 집합 나열

* 레이블은 레이블 셀렉터와 함께 사용됨
* 레이블 셀렉터는 특정 레이블로 태그된 파드의 부분 집합을 선택해 원하는 작업을 수행할 수 있음
* 레이블 셀렉터는 아래의 기준에 따라 리소스를 선택할 수 있음
  1. 특정한 키를 포함하거나 포함하지 않는 레이블
  2. 특정한 키와 값을 가진 레이블
  3. 특정한 키를 갖고 있지만, 다른 값을 가진 레이블

```bash
# creation_method 레이블이 manual인 파드만 조회
k get po -l creation_method=manual
# creation_method 레이블이 manual, env가 debug인 파드 조회
k get po -l creation_method=manual,env=debug
# env 레이블을 가진 파드만 조회 (값은 상관없음)
k get po -l env
# env 레이블을 가지지 않은 파드만 조회 (''로 감싸줘야 bash가 !를 처리하지 않음)
k get po -l '!env'

# creation_method 레이블을 가지고 있지만 값이 manual 이 아닌 것
# (210627) 직접해보니 해당 레이블이 없는 파드도 조회된다. 즉, creation_method 가 없거나 있을 경우 manual이 아닌 파드가 조회됨.
k get po -l 'creation_method!=manual'
# env 레이블이 prod 또는 debug인 파드
k get po -l 'env in (prod,debug)'
# not in
k get po -l 'env notin (prod,debug)'
```

## 레이블과 셀렉터를 이용해 파드 스케줄링 제한

* 기본적으로 파드는 워커 노드 전체에 무작위로 스케줄링됨
* 그러나 SSD 를 사용한다거나 GPU 사용이 가능한 노드에만 파드를 배포해야하는 경우가 있을 수 있음
* 이 경우에도 레이블을 이용할 수 있음

```bash
# 특정 노드에 gpu 가 있음을 알리는 레이블 지정
k label node docker-desktop gpu=true
```

* 노드 셀렉터를 활용하여 특정 레이블을 가진 노드에만 배포되도록 할 수 있음

```yaml
# kubia-gpu.yaml
# ...
spec:
    nodeSelector:
      gpu: "true"
    containers:
    - image : luksa/kubia
      name: kubia
# ...
```

* 각 노드는 기본적으로 몇 가지 레이블을 가지는데 그 중에서 `kubernetes.io/hostname` 레이블은 각 노드의 호스트네임을 값으로 가짐. 이 점을 활용하여 특정 노드에 배포하는 것도 가능은 함.
  * 그러나 해당 노드에 문제가 생길 경우 그대로 장애로 이어지므로 특정 노드를 지정하는 것은 올바른 방법이 아님
  * 대신 `GPU 를 가진 노드에만 배포한다`와 같이 특정 속성을 가진 노드 그룹의 단위로 생각하는 것이 올바름

## 파드에 어노테이션 달기

* 레이블과 유사하게 `키-값` 쌍의 정보
* 레이블은 특정 오브젝트를 묶는 데 사용하거나 레이블 셀렉터로 특정 오브젝트를 선택할 수 있지만 어노테이션은 그런 기능은 없고 단순 정보 제공만 가능함
* 대신 어노테이션은 레이블과 달리 긴 정보를 지정하는데 적합하고 최대 256KB까지 저장가능
* 사용예를 들면 흔히 쿠버네티스에 신규 기능을 도입할 때 바로 필드로 추가되는게 아니라 일단 어노테이션으로 실험하고 공식 기능으로 들어가면 필드로 추가되고 해당 어노테이션의 사용이 중단되는 방식으로 사용한다고 함
* 그 외에 오브젝트에 설명을 추가하는 용도로 쓰임. 오브젝트에 대한 주석이라고 보면 될 듯.


```yaml
# 레이블과 마찬가지로 yaml에 annotation 을 정의할 수 있음
# 어노테이션 이름은 예제와 같이 계층구조로 정의하는 것이 좋은데 다른 도구나 라이브러리가 어노테이션을 덮어씌우는 문제를 회피하기 위함임
apiVersion: v1
kind: Pod
metadata:
  annotations:
    mycompany.com/annotation1: foo bar
# ...
```

```bash
# 명령어로 어노테이션 추가 및 수정
k annotate pod kubia-manual mycompany.com/annotation2="foo bar2"

# 어노테이션 조회
k get po kubia-manual -o yaml | less
```

```yaml
apiVersion: v1
kind: Pod
metadata:
  annotations:
    mycompany.com/annotation1: foo bar
    mycompany.com/annotation2: foo bar2
# ...
```

```bash
# 또는 describe 로도 볼 수 있음
k describe pod kubia-manual | grep -A5 Annotations
```